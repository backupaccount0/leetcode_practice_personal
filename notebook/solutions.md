# 题目思路记录笔记
# 一、数组
## 1. #704 二分查找
可以使用二分查找的条件：1.有序 2. 无重复<br>

查找区间为左闭右闭<br>
有三个索引位置， low， high， mid = (low + high) / 2<br>
若mid处的值等于target，直接返回mid <br>
若mid处的值大于target，则将搜索范围缩小一半至[low, mid-1] <br>
若mid处的值小于target，则将搜索范围缩小一半至[mid+1, high] <br>
+1 和 -1 的原因是搜索区域为左闭又闭，因此需要将已经验证过不是target的位置mid排除在外 <br>
这样的话，while循环的条件就是low <= high，因为经过循环内的加减条件存在low=high=mid的情况还没有验证过<br>


## 2. #27 移除元素
双指针之快慢指针：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作<br>

快指针遍历数组，慢指针指向更新后数组的最后一位<br>
在使用快指针遍历的过程中，<br>
若目标值和快指针索引值相同，则不更新慢指针，由for循环更新快指针，<br>
若目标值和快指针索引值不同，则先将快指针索引值赋给慢指针索引处(当快慢指针不同时)，再将慢指针加一，同样由循环更新快指针<br>
这样可以达到时间复杂度O(n)和空间自由度O(1)<br>


## 3. #977 有序数组的平方
双指针之对撞指针：两个指针从两边像中间靠拢<br>

首先声明一个存放结果的数组，大小和输入数组一样，可以直接拷贝输入数组<br>
遍历数组，比较左右两个索引值平方的大小，依次将较大的值按从右到左的顺序填在结果数组中，<br>
更新索引，若添加的左指针，则将左指针加1,若添加的右指针，则将右指针减一<br>


## 4. #209 长度最小的子数组
双指针之滑动窗口<br>
滑动窗口确认三点：
1. 窗口内是什么？
2. 如何移动窗口的起始位置？
3. 如何移动窗口的终止位置？
<br>
本题回答：<br>
1. 窗口内是满足和大于s的子数组
2. 当窗口的值大于等于s了，就可以将窗口的起始位置向右移，减小子数组长度及和的大小，再次验证窗口值是否还大于等于s
3. 终止位置是遍历输入数组的index，若窗口内和小于s了，就要将终止位置右移
选择窗口终止位置作为遍历数组的index，可以减少对窗口是否超出数组长度的检验，更加简便


## 5. #59 螺旋数组II
模拟行为<br>

从外向内画圈，画圈的次数为n/2，若n为奇数，矩阵最中心位置为n^2<br>
循环画圈的次数，按照从左至右，从上至下，从右至左，从下至上（顺时针）依次填充，索引位置与圈数和n有关<br>
每个方向填充的个数要相同，将最后一个位置留给下一次填充，如n=3，则第一圈第一行先只添充2个元素(即：在左闭右开区间内循环)<br>

# 二、链表
## 6. #203 移除链表元素
链表的头节点不能删除，只能移动，因此删除头节点和其他位置节点的操作是不同的，添加一个虚拟的头指针，指向真正的头指针，即可避免掉特殊情况的处理，同等地对待所有指针

将当前节点初始化为虚拟头指针，while 循环判断，若下一节点的值等于target value，则将当前节点的指针指向下下节点，并删除下一节点。

(手动删除节点的原因：c++只更新指向下一位的指针，不会自动删除已经脱离链表的元素，python等语言会自动删除，无需手动)

否则将当前节点更新为下一节点。最后别忘了删除虚拟头节点，返回值为虚拟头节点的下一位

维护当前节点，判断下一节点，是否需要更新当前节点的next指针


## 7. #707 设计链表


## 8. #206 反转链表
双指针，慢指针指向前一个节点(初始化为nullptr)，快指针指向当前节点

首先判空！直接返回头指针

循环当前节点（快指针），若当前节点为nullptr则退出循环。

循环内首先记录下下一个节点，以免更改了当前节点的next指针后丢失下一节点。

在将当前节点的next赋为上一节点。

更新慢指针（前一节点为当前节点），再更新快指针（当前节点为下一节点）

最终返回慢指针


## 9. #24 两两交换链表中的节点
模拟行为

绘制链表元素指针变换的图以模拟行为

首先判空，或单元素，直接return head

注意区分size单双数的情况

维护4个节点，当前节点对的左节点和右节点，下一节点对的左节点和右节点

while循环的终止条件是，当前节点对的右节点非nullptr

在循环内，先记录下下一节点对的左右节点以防信息丢失（若左节点为nullptr，则右节点也记录为nullptr）

若当前节点

再先更新右节点指向左节点，再更新左节点指向下一节点对的右节点（下一节点对的右节点非nullptr）或左节点（下一节点对的右节点为nullptr）

最后更新下一节点对的左右节点为当前节点对的左右节点


## 10. #19 删除链表的倒数第N个节点
快慢指针，慢指针指向被删除节点的前一位，快指针指向慢指针后的n位

声明并初始化虚拟头节点指向真正的头节点

慢指针初始化为虚拟头节点，快指针指向慢指针后的n位

while循环快指针，

循环内，判断，若快指针的下一位为nullptr，则说明到达了链表终点，此时应将慢指针节点指向下下一位（若需要彻底清除被删除的节点内存，则需要先将其记录下来）。

否则，就不断更新快慢指针分别至其下一位。

最终返回虚拟头节点的下一位为真正头节点，返回前别忘了删除虚拟头指针和被清除的节点

## 11. #106 链表相交
首先判断若有任何一个链表为空，则直接返回nullptr

根据题目描述若两个链表相交，则最后的一个或若干个节点应相同。

所以可以先遍历两个链表求出其长度，再将两个列表的末端对齐。忽略长列表前面多出来的那部分。

再遍历对齐的部分（较短的列表），若出现相同的节点则返回该节点，否则前进至下一个节点，若最终都没有相同的节点则返回nullptr

时间复杂度为O(n)，空间复杂度为O(1)

## 12. #142 环形链表
快慢指针， 快指针速度为慢指针2倍

若链表有环，那么快慢指针一定会在环内相遇，否则快指针会为nullptr或快指针的next为nullptr退出循环。

相遇时慢指针走过:x(头结点到环入口的距离：即待求量)+y(环入口到相遇点的距离)，快指针走过:x+n个环长+y

快慢指针运动时间相同，因此快指针走过的距离是慢指针的2倍：x+n个环长+y = 2(x+y) => x = n个环长-y，将环长拆分为y(环入口到相遇点的距离)和z(相遇点到环入口的距离)

则得到等式：x = z + (n-1)(y+z) => x = z + (n-1)个环长

模拟一下快慢指针在环内的相遇过程，可以发现n至少为1，等于1时，x = z，因此可以在相遇后将慢指针回退到头结点，快指针不动，二者同时向前，再次相遇时则为环入口。

若n大于1，则是快指针在环内循环等待慢指针，使用while循环判断快慢指针是否相等即可覆盖n>=1的所有情况。


# 三、哈希表

## 13. #242 有效的字母异位词
查找是否出现的问题，用哈希表

比起用map，用数组更加方便。数组就是一个简单的哈希表，key为index，value为索引值

小写字母a到z在ASCII中是26个连续的数值，都减去'a'的ASCII码，即为0-26。

因此初始化一个大小为26，值为0的int数组。

遍历第一个字符串，若出现相应的字母，则在该index(char-'a')处加1。

遍历第二个字符串，若出现相应的字母，则在该index(char-'a')处减1。

最后遍历记录数组，若有非0的值，则返回false。否则循环结束，返回true。

## 14. #1002 查找常用字符
查找，小写字符 -> 哈希法(数组)

维护一个二维数组统计字母出现的次数，每一个数组是一个26维的int数组，表示一个单词中字母出现的次数。

首先遍历输入words数组，填好字母出现的次数。

每一行是一个单词26个字母出现的次数，每一列是一个字母在每个单词中出现的次数

统计每一列的最小值，最小值为几，则该字母在每个单词中都至少出现了几次，也就是要在输出的字符串数组中添加相应次数的该字母。

## 15. #349 两个数组的交集
查找，去重，顺序无影响 -> 哈希法（unordered_set）

将一个输入数组1转换成unordered_set，同时初始化一个unordered_set记录重复值。

遍历另一个输入数组2，若元素在数组2的集合中，则将其添加到重复值set中。

最终将重复值的unordered_set转换为数组返回。

## 16. #202 快乐数
无限循环：如何判断何时陷入无限循环：当某个加和结果出现过时，则会陷入无限循环，此时应直接return false

否则一直循环，直到和为1

初始化一个unordered_set用来记录出现过的和值，每次计算出新的和值后判断该和值是否出现过，若出现过，则return false，否则若和为1，return true，否则，将和值添加到集合中。

## 17. #1 两数之和
如何记录出现过的数字：维护一个unordered_map，key为target减去该数字，value为该数字的index。

这样在遍历输入数组的时候，对于每一个数字，检查它与target的差值是否在该map中出现过，若出现过，则返回该数字的index，加上map中获取到的差值(key)的index(value)。

否则，将该数字与target的差值和其index添加到map中，

循环直至找到解为止，否则返回空。

## 18. #454 四数相加II
一共有四个数，相加为0，则两两相加必为相反数。

首先以O(n^2)的复杂度遍历前两个数组，以两数之和为key，该和出现的次数为value创建出一个unordered_map。

再以O(n^2)的复杂度遍历后两个数组，若两数之和的相反数在map中出现过，则多了map相应value个解。

最终返回解的个数。

## 19. #383 赎金信
小写字母，查找是否存在 -> 哈希法(数组)

首先遍历两个字符串，统计每个字母出现的次数，储存在两个长度为26的数组中

遍历统计数组，若对于相同字母，ransomNote中出现的次数大于magazine中出现的次数，则返回false，否则循环结束，返回true。

## 20. #15 三数之和
首先，标准库中unordered_map的元素不能为vector。因此用哈希表处理解的重复问题是比较麻烦的。

用双指针法，（复杂度为O(n^2)）

先排序！！！！！

遍历数组，索引为i，左指针为i+1，右指针为数组最末位。

在每一次遍历中，若三个位置的和大于0，则将右指针向左移，若小于零，则将左指针向右移，直到得到第一组解，或左右指针相撞，跳出循环，进入数组的下一个迭代。

若在本次迭代中有解，则修改左右指针，查看是否在该索引处还有其他解。

若左指针的右侧与其值相等且左右指针未相撞，则不断将左指针右移

若右指针的左侧与其值相等且左右指针未相撞，则不断将右指针左移

最后再将左指针右移一位，右指针左移一位，以使得左右指针指向不同的值。

以同样的循环查找解，直至左右指针相撞。

为了避免重复，要注意，在进入数组的每次迭代后，立即检查，该值与上一位是否相等，若相等，则可直接进入下一个迭代，不必做后续检查。

## 21. #18 四数之和
15题三数之和的升级版，多外套一层for循环

用双指针将时间复杂度从O(n^4)降为O(n^2)

（若nums的长度小于4，可直接返回空）

先排序！！！！！！

遍历 i, j，初始时左指针为j+1，右指针为nums.size()-1

在进入两层循环开始时，先分别检查i，j是否与上一位重复，若有则直接进入下一次迭代。

否则按照三数之和的方法更新左右指针寻找解。

注意求和的时候可能会涉及到超限，因此将int转为long

# 四、字符串
## 22. #344 反转字符串
O(1)的空间复杂度，双指针->对撞指针

左指针从第一位起，右指针从最后一位起。

当左指针小于右指针，交换左右指针处的值（用swap比较简单）

左指针向右一位，右指针向左一位

## 23. #541 反转字符串II
for循环数组，每次循环i+=2k

每次循环内使用双指针反转i至i+k-1范围内的字符串

注意判断若右指针超限，则将右指针赋为最后一位

## 24. #剑指05 替换空格
填充数组(数组变长)：
1. 先扩充数组至目标大小
2. 从后向前填充（双指针）

这样能够避免为新数组申请内存，以O(1)空间复杂度解决问题，

且避免从前向后填充时，需要移动后面所有位置的元素，以O(n)得时间复杂度解决问题。

具体解法：

先数出字符串中空格得数量，resize字符串到输出结果得大小

双指针，一个指向就字符串得最后一位，一个指向新字符串得最后一位

不断将指针向前移动，直至到达字符串头部

若遇到空格则替换为%20，替换后指向新字符串得指针需要向前移动3位，旧字符串得指针向前移动1位。否则就将两个指针向前移动即可

## 25. #151 翻转字符串里的单词
分3步
1. 去除字符串中的多余空格：

    使用快慢指针，快指针遍历字符串，只有遇到非空格字符才会把快指针处的字符更新给慢指针处，并且将慢指针向前移动一位，

    每次新遇到非空格字符且慢指针不为0时，则说明遇到了一个新单词，要在前面加上空格，并将慢指针向前移动一位。

    最后将字符串resize，为慢指针大小

2. 反转整个字符串：

    见344题;

3. 再反转每个单词：

    遇到空格或指针超限时，即可用左右指针框出一个单词，进行反转字符串操作。

## 26. #剑指58-II 左旋转字符串
方法1：

resize字符串大小为size()+k

将前k个字符移动后最后

再将第k位后的所有字符向前移动k位

reisze字符串大小为size()-k

方法2：

分别反转前k个字符组成的字符串，和其余字符组成的字符串

再反转整个字符串

## 27. #28 实现 strStr()
可用string::find(pos, size)，时间复杂度为O(m*n)

用KMP算法，时间复杂度为O(m+n)

KMP算法能够避免重复比较已经判断为相同的部分

首先创建一个next数组，记录子串最长的相同前后缀长度

再遍历被查找的长字符串，若查找到了一部分匹配，在出现不匹配时，将指向模板的index复位到当前位置前一位为索引的next数组元素值处即可，无需回退长字符串的index

[参考动画](https://www.youtube.com/watch?v=af1oqpnH1vA)

## 28. #459 重复的子字符串
若为满足题目要求的重复字符串，则将两个原完整字符串拼接成一个2倍长度的字符串，在该长字符串中一定能够找到另一个原字符串。

将长字符串的头尾两个元素去掉即可避免找到的是原字符串，而非拼接后新生成的

（用substr，时间复杂度为O(n)）

使用find查找子串即可，时间复杂度为O(m×n)，若需要O(m+n),可使用kmp

# 五、队列与栈
## 29. # 232 用栈实现队列
维护两个栈成员变量，

一个与队列中存放的元素相同，

一个用来在实现队列从头部弹出时辅助存放从栈的尾部先弹出的元素，

完成从头部弹出后，将剩余元素从辅助栈中移回

## 30. # 225 用队列实现栈
维护两个队列成员变量，

一个与栈中存放的元素相同，

一个用来在实现栈从尾部弹出时辅助存放从队列的头部先弹出的元素，

完成从尾部弹出后，将剩余元素从辅助队列中移回

## 31. #20 有效的括号
栈

维护一个栈，存储字符串中需要出现的右括号

遍历字符串，

每当遇到左括号，则向栈中压入相应的右括号

每当遇到右括号，若栈为空，则证明右括号多了，return false

或者该右括号与栈中的最后一位的右括号不相同（st.top()），则证明括回的顺序不对，也return false

否则，栈弹出最后一位

遍历结束，若栈为空，则return true， 否则，则证明左括号多了，return false

## 32. #1047 删除字符串中的所有相邻重复项
删除相邻重复元素：栈

维护一个栈

遍历字符串，若栈为空或者栈的最后一个元素和遍历到的字符串元素不同，就把该元素压入栈，否则（即相同），则弹出栈的最后一个元素

结束后把栈中的元素写入一个字符串中，可以初始化一个字符串，并resize到栈的大小，再从后往前填充

## 33. #150 逆波兰表达式求值
逆波兰表达式是这样求解的：

遍历输入数组，遇到符号，就把符号的左侧两个数字（或表达式）进行加减乘除

用栈来解决

遇到数字就压入栈，遇到符号就计算左侧两个数字进行该符号运算的结果，把这两个数字从栈中弹出，压入计算结果


## 34. #239 滑动窗口最大值
暴力搜索：O(mn)，会重复比较窗口内已经出现的值

使用单调队列，时间复杂度：O(n)

维护一个单调递减的队列来储存窗口中的元素，队列的第一位元素值最大，往后依次递减

用一个deque来实现单调队列的功能

1. push:

    当新元素的值小于等于队列尾元素时或队列为空时，直接在队列后面添加新元素即可，（这些头元素之后的元素都是后面有可能成为最大值的元素）

    当新元素的值大于尾元素时，不断删除尾元素，直至新元素小于尾元素或队列为空（新元素大于队列最大值），再压入新元素即可

2. pop:

    当期望被删除的元素和队列的头元素（最大值）相等时，删除头元素，否则无需做任何操作

    （不相等，是因为期望被删除的元素不在队列中）


这样遍历输入的数组，索引为窗口的最后一位，当索引小于窗口长度-1时，将元素push进单调队列即可

当索引大于等于窗口值-1时，先将索引位置元素push进单调队列，拿到最大值（单调队列的头元素）

再将窗口最左侧的元素从单调队列中pop掉，该元素的索引应为最右侧的索引-窗口长度+1

## 35. #347 前 K 个高频元素
