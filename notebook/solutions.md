# 题目思路记录笔记
# 一、数组
## 1. #704 二分查找
可以使用二分查找的条件：1.有序 2. 无重复<br>

查找区间为左闭右闭<br>
有三个索引位置， low， high， mid = (low + high) / 2<br>
若mid处的值等于target，直接返回mid <br>
若mid处的值大于target，则将搜索范围缩小一半至[low, mid-1] <br>
若mid处的值小于target，则将搜索范围缩小一半至[mid+1, high] <br>
+1 和 -1 的原因是搜索区域为左闭又闭，因此需要将已经验证过不是target的位置mid排除在外 <br>
这样的话，while循环的条件就是low <= high，因为经过循环内的加减条件存在low=high=mid的情况还没有验证过<br>


## 2. #27 移除元素
双指针之快慢指针：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作<br>

快指针遍历数组，慢指针指向更新后数组的最后一位<br>
在使用快指针遍历的过程中，<br>
若目标值和快指针索引值相同，则不更新慢指针，由for循环更新快指针，<br>
若目标值和快指针索引值不同，则先将快指针索引值赋给慢指针索引处(当快慢指针不同时)，再将慢指针加一，同样由循环更新快指针<br>
这样可以达到时间复杂度O(n)和空间自由度O(1)<br>


## 3. #977 有序数组的平方
双指针之对撞指针：两个指针从两边像中间靠拢<br>

首先声明一个存放结果的数组，大小和输入数组一样，可以直接拷贝输入数组<br>
遍历数组，比较左右两个索引值平方的大小，依次将较大的值按从右到左的顺序填在结果数组中，<br>
更新索引，若添加的左指针，则将左指针加1,若添加的右指针，则将右指针减一<br>


## 4. #209 长度最小的子数组
双指针之滑动窗口<br>
滑动窗口确认三点：
1. 窗口内是什么？
2. 如何移动窗口的起始位置？
3. 如何移动窗口的终止位置？
<br>
本题回答：<br>
1. 窗口内是满足和大于s的子数组
2. 当窗口的值大于等于s了，就可以将窗口的起始位置向右移，减小子数组长度及和的大小，再次验证窗口值是否还大于等于s
3. 终止位置是遍历输入数组的index，若窗口内和小于s了，就要将终止位置右移
选择窗口终止位置作为遍历数组的index，可以减少对窗口是否超出数组长度的检验，更加简便


## 5. #59 螺旋数组II
模拟行为<br>

从外向内画圈，画圈的次数为n/2，若n为奇数，矩阵最中心位置为n^2<br>
循环画圈的次数，按照从左至右，从上至下，从右至左，从下至上（顺时针）依次填充，索引位置与圈数和n有关<br>
每个方向填充的个数要相同，将最后一个位置留给下一次填充，如n=3，则第一圈第一行先只添充2个元素(即：在左闭右开区间内循环)<br>

# 二、链表
## 6. #203 移除链表元素
链表的头节点不能删除，只能移动，因此删除头节点和其他位置节点的操作是不同的，添加一个虚拟的头指针，指向真正的头指针，即可避免掉特殊情况的处理，同等地对待所有指针

将当前节点初始化为虚拟头指针，while 循环判断，若下一节点的值等于target value，则将当前节点的指针指向下下节点，并删除下一节点。

(手动删除节点的原因：c++只更新指向下一位的指针，不会自动删除已经脱离链表的元素，python等语言会自动删除，无需手动)

否则将当前节点更新为下一节点。最后别忘了删除虚拟头节点，返回值为虚拟头节点的下一位

维护当前节点，判断下一节点，是否需要更新当前节点的next指针


## 7. #707 设计链表


## 8. #206 反转链表
双指针，慢指针指向前一个节点(初始化为nullptr)，快指针指向当前节点

首先判空！直接返回头指针

循环当前节点（快指针），若当前节点为nullptr则退出循环。

循环内首先记录下下一个节点，以免更改了当前节点的next指针后丢失下一节点。

在将当前节点的next赋为上一节点。

更新慢指针（前一节点为当前节点），再更新快指针（当前节点为下一节点）

最终返回慢指针


## 9. #24 两两交换链表中的节点
模拟行为

绘制链表元素指针变换的图以模拟行为

首先判空，或单元素，直接return head

注意区分size单双数的情况

维护4个节点，当前节点对的左节点和右节点，下一节点对的左节点和右节点

while循环的终止条件是，当前节点对的右节点非nullptr

在循环内，先记录下下一节点对的左右节点以防信息丢失（若左节点为nullptr，则右节点也记录为nullptr）

若当前节点

再先更新右节点指向左节点，再更新左节点指向下一节点对的右节点（下一节点对的右节点非nullptr）或左节点（下一节点对的右节点为nullptr）

最后更新下一节点对的左右节点为当前节点对的左右节点


## 10. #19 删除链表的倒数第N个节点
快慢指针，慢指针指向被删除节点的前一位，快指针指向慢指针后的n位

声明并初始化虚拟头节点指向真正的头节点

慢指针初始化为虚拟头节点，快指针指向慢指针后的n位

while循环快指针，

循环内，判断，若快指针的下一位为nullptr，则说明到达了链表终点，此时应将慢指针节点指向下下一位（若需要彻底清除被删除的节点内存，则需要先将其记录下来）。

否则，就不断更新快慢指针分别至其下一位。

最终返回虚拟头节点的下一位为真正头节点，返回前别忘了删除虚拟头指针和被清除的节点

## 11. #106 链表相交
首先判断若有任何一个链表为空，则直接返回nullptr

根据题目描述若两个链表相交，则最后的一个或若干个节点应相同。

所以可以先遍历两个链表求出其长度，再将两个列表的末端对齐。忽略长列表前面多出来的那部分。

再遍历对齐的部分（较短的列表），若出现相同的节点则返回该节点，否则前进至下一个节点，若最终都没有相同的节点则返回nullptr

时间复杂度为O(n)，空间复杂度为O(1)

## 12. #142 环形链表
快慢指针， 快指针速度为慢指针2倍

若链表有环，那么快慢指针一定会在环内相遇，否则快指针会为nullptr或快指针的next为nullptr退出循环。

相遇时慢指针走过:x(头结点到环入口的距离：即待求量)+y(环入口到相遇点的距离)，快指针走过:x+n个环长+y

快慢指针运动时间相同，因此快指针走过的距离是慢指针的2倍：x+n个环长+y = 2(x+y) => x = n个环长-y，将环长拆分为y(环入口到相遇点的距离)和z(相遇点到环入口的距离)

则得到等式：x = z + (n-1)(y+z) => x = z + (n-1)个环长

模拟一下快慢指针在环内的相遇过程，可以发现n至少为1，等于1时，x = z，因此可以在相遇后将慢指针回退到头结点，快指针不动，二者同时向前，再次相遇时则为环入口。

若n大于1，则是快指针在环内循环等待慢指针，使用while循环判断快慢指针是否相等即可覆盖n>=1的所有情况。


# 三、哈希表

## 13. #242 有效的字母异位词
查找是否出现的问题，用哈希表

比起用map，用数组更加方便。数组就是一个简单的哈希表，key为index，value为索引值

小写字母a到z在ASCII中是26个连续的数值，都减去'a'的ASCII码，即为0-26。

因此初始化一个大小为26，值为0的int数组。

遍历第一个字符串，若出现相应的字母，则在该index(char-'a')处加1。

遍历第二个字符串，若出现相应的字母，则在该index(char-'a')处减1。

最后遍历记录数组，若有非0的值，则返回false。否则循环结束，返回true。

## 14. #1002 查找常用字符
查找，小写字符 -> 哈希法(数组)

维护一个二维数组统计字母出现的次数，每一个数组是一个26维的int数组，表示一个单词中字母出现的次数。

首先遍历输入words数组，填好字母出现的次数。

每一行是一个单词26个字母出现的次数，每一列是一个字母在每个单词中出现的次数

统计每一列的最小值，最小值为几，则该字母在每个单词中都至少出现了几次，也就是要在输出的字符串数组中添加相应次数的该字母。

## 15. #349 两个数组的交集
查找，去重，顺序无影响 -> 哈希法（unordered_set）

将一个输入数组1转换成unordered_set，同时初始化一个unordered_set记录重复值。

遍历另一个输入数组2，若元素在数组2的集合中，则将其添加到重复值set中。

最终将重复值的unordered_set转换为数组返回。

## 16. #202 快乐数
无限循环：如何判断何时陷入无限循环：当某个加和结果出现过时，则会陷入无限循环，此时应直接return false

否则一直循环，直到和为1

初始化一个unordered_set用来记录出现过的和值，每次计算出新的和值后判断该和值是否出现过，若出现过，则return false，否则若和为1，return true，否则，将和值添加到集合中。

## 17. #1 两数之和
如何记录出现过的数字：维护一个unordered_map，key为target减去该数字，value为该数字的index。

这样在遍历输入数组的时候，对于每一个数字，检查它与target的差值是否在该map中出现过，若出现过，则返回该数字的index，加上map中获取到的差值(key)的index(value)。

否则，将该数字与target的差值和其index添加到map中，

循环直至找到解为止，否则返回空。

## 18. #454 四数相加II
一共有四个数，相加为0，则两两相加必为相反数。

首先以O(n^2)的复杂度遍历前两个数组，以两数之和为key，该和出现的次数为value创建出一个unordered_map。

再以O(n^2)的复杂度遍历后两个数组，若两数之和的相反数在map中出现过，则多了map相应value个解。

最终返回解的个数。

## 19. #383 赎金信
小写字母，查找是否存在 -> 哈希法(数组)

首先遍历两个字符串，统计每个字母出现的次数，储存在两个长度为26的数组中

遍历统计数组，若对于相同字母，ransomNote中出现的次数大于magazine中出现的次数，则返回false，否则循环结束，返回true。

## 20. #15 三数之和
首先，标准库中unordered_map的元素不能为vector。因此用哈希表处理解的重复问题是比较麻烦的。

用双指针法，（复杂度为O(n^2)）

先排序！！！！！

遍历数组，索引为i，左指针为i+1，右指针为数组最末位。

在每一次遍历中，若三个位置的和大于0，则将右指针向左移，若小于零，则将左指针向右移，直到得到第一组解，或左右指针相撞，跳出循环，进入数组的下一个迭代。

若在本次迭代中有解，则修改左右指针，查看是否在该索引处还有其他解。

若左指针的右侧与其值相等且左右指针未相撞，则不断将左指针右移

若右指针的左侧与其值相等且左右指针未相撞，则不断将右指针左移

最后再将左指针右移一位，右指针左移一位，以使得左右指针指向不同的值。

以同样的循环查找解，直至左右指针相撞。

为了避免重复，要注意，在进入数组的每次迭代后，立即检查，该值与上一位是否相等，若相等，则可直接进入下一个迭代，不必做后续检查。

## 21. #18 四数之和
15题三数之和的升级版，多外套一层for循环

用双指针将时间复杂度从O(n^4)降为O(n^2)

（若nums的长度小于4，可直接返回空）

先排序！！！！！！

遍历 i, j，初始时左指针为j+1，右指针为nums.size()-1

在进入两层循环开始时，先分别检查i，j是否与上一位重复，若有则直接进入下一次迭代。

否则按照三数之和的方法更新左右指针寻找解。

注意求和的时候可能会涉及到超限，因此将int转为long

# 四、字符串
## 22. #344 反转字符串
O(1)的空间复杂度，双指针->对撞指针

左指针从第一位起，右指针从最后一位起。

当左指针小于右指针，交换左右指针处的值（用swap比较简单）

左指针向右一位，右指针向左一位

## 23. #541 反转字符串II
for循环数组，每次循环i+=2k

每次循环内使用双指针反转i至i+k-1范围内的字符串

注意判断若右指针超限，则将右指针赋为最后一位

## 24. #剑指05 替换空格
填充数组(数组变长)：
1. 先扩充数组至目标大小
2. 从后向前填充（双指针）

这样能够避免为新数组申请内存，以O(1)空间复杂度解决问题，

且避免从前向后填充时，需要移动后面所有位置的元素，以O(n)得时间复杂度解决问题。

具体解法：

先数出字符串中空格得数量，resize字符串到输出结果得大小

双指针，一个指向就字符串得最后一位，一个指向新字符串得最后一位

不断将指针向前移动，直至到达字符串头部

若遇到空格则替换为%20，替换后指向新字符串得指针需要向前移动3位，旧字符串得指针向前移动1位。否则就将两个指针向前移动即可

## 25. #151 翻转字符串里的单词
分3步
1. 去除字符串中的多余空格：

    使用快慢指针，快指针遍历字符串，只有遇到非空格字符才会把快指针处的字符更新给慢指针处，并且将慢指针向前移动一位，

    每次新遇到非空格字符且慢指针不为0时，则说明遇到了一个新单词，要在前面加上空格，并将慢指针向前移动一位。

    最后将字符串resize，为慢指针大小

2. 反转整个字符串：

    见344题;

3. 再反转每个单词：

    遇到空格或指针超限时，即可用左右指针框出一个单词，进行反转字符串操作。

## 26. #剑指58-II 左旋转字符串
方法1：

resize字符串大小为size()+k

将前k个字符移动后最后

再将第k位后的所有字符向前移动k位

reisze字符串大小为size()-k

方法2：

分别反转前k个字符组成的字符串，和其余字符组成的字符串

再反转整个字符串

## 27. #28 实现 strStr()
可用string::find(pos, size)，时间复杂度为O(m*n)

用KMP算法，时间复杂度为O(m+n)

KMP算法能够避免重复比较已经判断为相同的部分

首先创建一个next数组，记录子串最长的相同前后缀长度

再遍历被查找的长字符串，若查找到了一部分匹配，在出现不匹配时，将指向模板的index复位到当前位置前一位为索引的next数组元素值处即可，无需回退长字符串的index

[参考动画](https://www.youtube.com/watch?v=af1oqpnH1vA)

## 28. #459 重复的子字符串
若为满足题目要求的重复字符串，则将两个原完整字符串拼接成一个2倍长度的字符串，在该长字符串中一定能够找到另一个原字符串。

将长字符串的头尾两个元素去掉即可避免找到的是原字符串，而非拼接后新生成的

（用substr，时间复杂度为O(n)）

使用find查找子串即可，时间复杂度为O(m×n)，若需要O(m+n),可使用kmp

# 五、队列与栈
## 29. # 232 用栈实现队列
维护两个栈成员变量，

一个与队列中存放的元素相同，

一个用来在实现队列从头部弹出时辅助存放从栈的尾部先弹出的元素，

完成从头部弹出后，将剩余元素从辅助栈中移回

## 30. # 225 用队列实现栈
维护两个队列成员变量，

一个与栈中存放的元素相同，

一个用来在实现栈从尾部弹出时辅助存放从队列的头部先弹出的元素，

完成从尾部弹出后，将剩余元素从辅助队列中移回

## 31. #20 有效的括号
栈

维护一个栈，存储字符串中需要出现的右括号

遍历字符串，

每当遇到左括号，则向栈中压入相应的右括号

每当遇到右括号，若栈为空，则证明右括号多了，return false

或者该右括号与栈中的最后一位的右括号不相同（st.top()），则证明括回的顺序不对，也return false

否则，栈弹出最后一位

遍历结束，若栈为空，则return true， 否则，则证明左括号多了，return false

## 32. #1047 删除字符串中的所有相邻重复项
删除相邻重复元素：栈

维护一个栈

遍历字符串，若栈为空或者栈的最后一个元素和遍历到的字符串元素不同，就把该元素压入栈，否则（即相同），则弹出栈的最后一个元素

结束后把栈中的元素写入一个字符串中，可以初始化一个字符串，并resize到栈的大小，再从后往前填充

## 33. #150 逆波兰表达式求值
逆波兰表达式是这样求解的：

遍历输入数组，遇到符号，就把符号的左侧两个数字（或表达式）进行加减乘除

用栈来解决

遇到数字就压入栈，遇到符号就计算左侧两个数字进行该符号运算的结果，把这两个数字从栈中弹出，压入计算结果


## 34. #239 滑动窗口最大值
暴力搜索：O(mn)，会重复比较窗口内已经出现的值

使用单调队列，时间复杂度：O(n)

维护一个单调递减的队列来储存窗口中的元素，队列的第一位元素值最大，往后依次递减

用一个deque来实现单调队列的功能

1. push:

    当新元素的值小于等于队列尾元素时或队列为空时，直接在队列后面添加新元素即可，（这些头元素之后的元素都是后面有可能成为最大值的元素）

    当新元素的值大于尾元素时，不断删除尾元素，直至新元素小于尾元素或队列为空（新元素大于队列最大值），再压入新元素即可

2. pop:

    当期望被删除的元素和队列的头元素（最大值）相等时，删除头元素，否则无需做任何操作

    （不相等，是因为期望被删除的元素不在队列中）


这样遍历输入的数组，索引为窗口的最后一位，当索引小于窗口长度-1时，将元素push进单调队列即可

当索引大于等于窗口值-1时，先将索引位置元素push进单调队列，拿到最大值（单调队列的头元素）

再将窗口最左侧的元素从单调队列中pop掉，该元素的索引应为最右侧的索引-窗口长度+1

## 35. #347 前 K 个高频元素


# 六、二叉树

## 36. #144 二叉树的前序遍历
## 37. #145 二叉树的后序遍历
## 38. #94 二叉树的中序遍历

前序： 父节点->左子节点->右子节点

后序：左子节点->右子节点->父节点

中序： 左子节点->父节点->右子节点

### 递归解决

1. 确定递归函数的输入参数和返回值

2. 确定递归函数的基线条件（终止递归条件），若满足，则return，写在递归函数最开始

3. 确定递归函数内的逻辑，按顺序做什么操作，可能设计到递归函数本身的调用

在主函数调用递归函数即可，输入参数一般为根节点


### 迭代解决
深度优先，用stack

1. 前序：

    首先判空

    维护一个stack，先把根节点压入stack

    当stack不为空时，取栈的top节点，

    把该节点的值添加到结果数组中，并弹出这个节点

    再把该节点的不为空的右左节点压入栈中（注意顺序：右左，这样从栈中弹出来的才是左右的顺序）

2. 后序：

    前序：中左右 -> 中右左 -> 后序：左右中

    将前序迭代方法中，添加字节点的顺序由右左，改为左右，再将得到的结果数组反转，即可得到后序遍历的结果

3. 中序：

    由于中序遍历中，遇到了中节点时不能理解把该节点结果放入数组中，因此需要在维护一个stack的同时，用一个指针记录下遍历的位置

    初始化一个stack，同时，使得当前节点指向根节点

    当当前节点非nullptr或者stack不为空的时候：

    如果当前节点为nullptr：并把节栈顶部节点的值添加到结果数组中，并把当前节点更新为栈顶部元素的右子节点，再弹出栈的顶部元素

    如果当前节点不为nullptr：就把当前节点压入栈， 并把当前节点更新为当前节点的左子节点

## 39. #102 层序遍历

1. 迭代解决

广度有限：用queue

先判空

维护一个队列queue

while循环，当queue不为空时，先记录下queue size（由于遍历que的过程中会进行增删，会改变queue size），

初始化一个int vector 用来记录这一层的结果

for循环遍历queue，将头节点元素值填入该层的结果数组中，将头节点不为空的左右子节点添加至队列中，再删除头节点

将该层的结果添加至最终的二维结果数组中，进入下一次while循环

2. 递归解决

递归函数一次遍历一层

参数为队列和结果数组，皆为引用，递归函数内部会修改队列和结果数组

终止条件为队列为空

## 40. #107 层序遍历II
二叉树的层序遍历（102题）+ 结果反转（O(n))

## 41. #199 二叉树的右视图
二叉树的层序遍历（102题）+ 只记录每层的最后一个值

## 42. #637 二叉树的层平均值
二叉树的层序遍历（102题）+ 只记录每层的平均值

## 43. #429 N叉树的层序遍历
二叉树的层序遍历（102题）+ 每个节点可能有N个子节点而非左右两个

## 44. #515 在每个树行中找最大值
二叉树的层序遍历（102题）+ 记录每层的最大值

（最大最小的int值：INT_MIN，INT_MAX）

## 45./46. #116/117 填充每个节点的下一个右侧节点指针(II)
二叉树的层序遍历（102题）+ 层内连接节点，若为该层最后一个节点，则next为nullptr

也可以用递归来解决，模拟指向过程，空间复杂度：O(1)

## 47. #104 二叉树的最大深度
二叉树的层序遍历（102题）+ 循环一层层数加一

## 48. #111 二叉树的最小深度
二叉树的层序遍历（102题）+

每进入一层循环，深度先加一

在每层的遍历中，若遇到节点的左右子节点皆为空，则说明到达了叶节点，直接return 深度;

否则全部遍历结束后，再return 深度

## 49. #226 翻转二叉树
层序或前序遍历二叉树，对于每一个节点，交换左右子节点即可(swap)

可以用递归或迭代解决

## 50. #101 对称二叉树

将二叉树分为左右两个，分别遍历

1. 迭代法

左侧树按照左到右的层序遍历，右侧树按照右到左的层序遍历

空节点也要放入队列中

要注意判断若两个节点皆为空，则判断为两节点相等

若其中只有一个为空，则判断不等

若都不为空，再检查节点的值是否相等

2. 递归法

递归函数参数为：左右树的两个节点， 返回的是该节点是否相等（比较节点值，左右子节点值）

终止条件为：两个参数节点都为空， return true

判断节点是否相等的过程： 若仅有一个节点为空，则return false

否则，两个节点都不为空，若两个节点的值不想等，则return false;

然后递归调用函数本身，

比较左树节点的左子节点和右树节点的右子节点以及左树节点的右子节点和右树节点的左子节点

（可以理解为不断比较缩小所有子树）

若都相等，则return true

## 51. #100 相同的树
与101题相似，终止条件相同，

每次递归内，判断两颗子树的左节点，和右节点是否分别相等，且当前节点的值是否相等

## 52. #104 二叉树的最大深度
后序遍历递归解决

终止条件为节点为nullptr，返回0

函数参数为父节点

递归调用函数本身获取到左右子节点的最大高度（距离最远叶子节点的层数）

返回左右子节点高度最大值 + 1

也可以用前序遍历（求得是深度）

## 53. #111 二叉树的最小深度
类似104题，同样用后序遍历递归法解决

终止条件为节点为nullptr，返回0

函数参数为父节点

递归调用函数本身获取到左右子节点的最大高度（距离最远叶子节点的层数）

如果左右子节点有任意一个为空，那么那边不算有子树，要返回非空子节点的高度+1

（可以认为返回左右子节点高度最大值+1,因为空节点的高度值为0）

否则，及左右子节点皆非空，那么返回左右子节点高度最小值 + 1

## 54. #222 完全二叉树的节点个数

后序遍历递归

终止条件为节点为nullptr，返回0

函数参数为父节点

递归调用函数本身获取左右子节点的作为子树跟节点的子树节点个数

返回左右子树节点个数和+1（1代表父节点本身）

## 55. #110 平衡二叉树
后序遍历递归

使用递归函数获取二叉树的高度

递归函数的参数是父节点，返回以父节点为根节点的子树最大高度，-1表示子树已非平衡二叉树

终止条件是：若节点为空，则返回0

否则，递归调用函数本身获得左右子树的高度，若为-1,直接return -1,

否则，当前节点的高度值=左右子树高度的最大值+1,return当前节点高度

在主函数内，如果以参数为root，调用递归函数，返回的是-1,则为非平衡二叉树，return false，

否则，return true

本题在递归函数内用整数-1表示了布尔值（是否为平衡二叉树），

递归函数也可以返回布尔值，将左右字数的高度作为引用参数

## 56. #257 二叉树的所有路径

前序遍历的递归+回溯

递归函数的参数有：当前节点，&记录所有路径的string vector，&记录当前路径的int vector

递归函数的基线条件是：遇到叶子节点，也就是当前节点非空，但是左右字节点结尾空的时候：

将当前节点的值放入当前路径中，再将这一条路径用字符串表示放入结果数组中，然后return

否则，在每次递归内，先把当前节点的值放入路径vector中，

再判断如果当前节点的左子节点非空，就递归调用函数本身，节点从当前节点变为左节点，

当调用完成时，也就是到达了叶子节点时，要将路径vector的最后一个元素（叶子节点）删除 -->>  即：回溯

同样地处理右子节点。

！！！回溯和递归是一一对应的，有一个递归就要有一个回溯，应该出现在同一个花括号内

## 57. #404 左叶子之和

什么是左叶子：若父节点非空，左子叶非空，且左子叶的左右子叶皆为空，那么这个左子叶为左叶子节点

递归的基线条件：节点为空或者为叶子节点（左右子节点皆为空）

每次递归内：

若当前节点的左子节点为左叶子，

那么以当前节点作为根节点的子树的左叶子之和为:

左叶子的值 + 以右子节点为根节点的子树的左叶子之和（递归调用函数，参数由cur_node变为cur_node->right） -> 返回值

否则，

以当前节点作为根节点的子树的左叶子之和为:

以左子节点为根节点的子树的左叶子之和 （递归调用函数，参数由cur_node变为cur_node->left) + 以右子节点为根节点的子树的左叶子之和（递归调用函数，参数由cur_node变为cur_node->right）-> 返回值

## 58. #513 找树左下角的值
层序遍历，维护一个queue，每一次迭代，queue中含有这一层的所有节点

每一层记录下来queue的第一个元素值，然后将queue中每个节点的左右节点添加到queue中，并pop掉这一层的所有节点

直到queue为空，退出while循环

return 最后一个记录下来的queue front val即可

## 59. #112 路径总和
前序遍历的递归

递归函数的参数是：当前节点，路径，目标值

基线条件是：遇到了叶子节点，将当前节点的值加入路径，判断路径的和值是否等于目标值，返回相应的true or false

否则，在每次递归内，先将当前节点的值加入路径，

然后若左子节点非空，那就递归调用函数，当前节点更新为左子节点

若递归调用返回值为true，则return true，

递归结束后，说明遇到了叶子节点，别忘了从路径中pop掉最后一个元素

同样的处理右子节点

否则，证明皆为false，那就返回false

## 60. #113 路径总和II
与112题类似，但是无需返回值，以函数参数引用的形式记录满足条件的路径到结果数组中

基线条件：若遇到叶子节点，且加上了叶子节点后路径和等于目标值，就把该路径放到结果数组中，否则什么也不做，直接return

递归调用与112题类似

注：

若需要搜索整棵二叉树，且不用处理递归返回值，递归函数就不要返回值（113题）

若需要搜索整棵二叉树，且要处理递归返回值，递归函数就需要返回值（236题）

若不需要搜索整棵二叉树，递归函数就需要返回值，遇到了符合条件的就即使返回（112题）

## 61. #106 从中序与后序遍历序列构造二叉树

后序的最后一个元素为根节点

在中序中找到这个元素，分割为左右两个部分，得到左右子节点中序遍历数组的长度

根据长度分割后序，（中序和后序的长度应该永远一致）

由此分别得到左右子节点的中序和后序

基线条件：若中序长度为1：则证明遇到了叶子节点，可以给节点val赋值为数组中唯一元素的值后直接return

否则，在每次递归内，给节点的val赋值为后序的最后一个元素，再分割出左右子节点的中后序遍历数组

若长度不为0，则证明有该方向子节点，初始化一个节点，并把这个节点链接到当前节点的左或右节点上

递归函数的参数为：当前节点，中序数组，后序数组

初始化一个TreeNode：TreeNode* node =new TreeNode();

## 62. #105 从中序与前序遍历序列构造二叉树
与106题类似，区别在于根节点在前序的首元素

另外，为了避免在每次递归内重复声明且初始化遍历数组，可以传递子数组的index，和大小

递归函数的参数为：当前节点，const &中序数组（完整的，没有分割）， const &前序数组（完整的，没有分割），

子中序数组数组的起始index，子前序数组数组的起始index， 数组长度（前中遍历的相等）

## 63. #654 最大二叉树

与105题构造二叉树类似

基线条件是： 遇到叶子节点，子序列的长度为1, 给节点val赋值后直接return

否则，在每次递归内，先找最大元素（max_elem），给节点val赋上最大值后，将序列分割为左右两个，

若分割后的左右子序列不为空，则声明左右子节点并与当前节点链接上，

再递归调用函数本身，参数节点由当前节点更新为左或右子节点

为了避免在每次递归内声明并初始化字节点，采用传递子序列初始index和size的方式

递归函数的参数为：当前节点， const &输入数组，子数组的起点index，子数组的size

## 64. #617 合并二叉树
前序递归

基线条件：若node1为空，return node2；若node2为空，return node1

否则，将两个节点的值相加，

再将node1的左节点赋值为 递归调用函数本身的结果，参数节点改变为node1->left和node2->left

node1的右节点赋值为 递归调用函数本身的结果，参数节点改变为node1->right和node2->right

并return node1


## 65. #700 二叉搜索树中的搜索

二叉搜索树：

若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；

若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；

它的左、右子树也分别为二叉搜索树

基线条件：若节点为空，则证明到了叶子节点，但还没有搜索到相等值，return nullptr

否则，在每次递归内，若节点值等于目标值，就return 该节点

若大于目标值，则递归搜索左侧节点 并return函数

若大于目标值，则递归搜索右侧节点 并return函数

## 66. #98 验证二叉搜索树

一个二叉搜索树的中序遍历数组是一个单调递增的数组

中序递归

在递归函数外，先初始化一个最大值，为LONG_MIN（因为测试集里面有INT_MIN）

基线条件：遇到空节点，return true

否则，在每次递归内，先检查左节点（递归调用函数本身），若左节点为false，直接return false；

然后检查中节点，若中节点，也就是当前节点本身的值小于等于已遍历过的最大值，则return false；

否则，将最大值更新为当前节点的值

再检查右节点，若右节点为false，直接return false；

否则，证明左中右节点皆满足要求，return true

## 67. #530 二叉搜索树的最小绝对差

中序遍历一个搜索二叉树，得到一个单调递增的节点值序列

维护两个类的私有成员变量：

1. 上一个节点的值，初始化为INT_MIN

2. 最小差，初始化为INT_MAX

递归函数void traversal

基线条件：节点为空，return;

否则在每次递归内，先遍历左子节点

若上一个节点值不为INT_MIN，也就是，不是第一个叶子节点时：

    判断当前节点值与上一节点值的差值是否为最小

    若是则更新最小差值，否则什么都不做

更新上一节点值为当前节点值

再遍历右子节点

主函数调用traversal，返回最小差

## 68. #501 二叉搜索树中的众数
中序遍历二叉搜索数

维护类的私有成员变量：

    1. 出现最多的数字的次数（众数的count），初始化为INT_MIN

    2. 当前数字出现次数的计数

    3. 上一个出现的节点值

    4. 需要被返回的结果：众数数组

递归函数void traversal

基线条件：节点为空，return;

在每次递归内，首先调用递归函数，遍历左子节点

对于中节点，首先判断他的值是不是一个新的未出现过的数字（用和上个节点的值比较来实现），

如果未出现过，则当前数字出现的次数更新为1，若出现过，则当前数字出现的次数在原本的基础上加1

然后判断当前数字出现的次数是否大于等于最大次数，

若大于，则要先清空众数数组，更新最大次数

然后不管大于还是等于，都把当前节点的值添加到众数数组中（等于，说明有多个数组）

最后再把上一个节点值赋为当前节点的值

结束后，再遍历右子节点

主函数返回众数数组

## 69. #236 二叉树的最近公共祖先
后序遍历

基线条件：当前节点为空，返回nullptr

后序遍历，先对左右子节点调用递归函数，记录下返回值left和right节点

对于当前节点进行判断，

若当前节点为两个待搜索节点之一，直接返回当前节点

否则检查左右子节点，若上面对左右子节点调用递归函数的返回值皆非空，则返回当前节点（此时说明遇到了公共祖先）

若有一方非空，则返回非空节点，

若皆为空，则返回空

（包含了公共祖先是其中一个待搜索节点的情况）

## 70. #235 二叉搜索树的最近公共祖先

一个二叉搜索数，从上到下遍历，若当前节点的值在待搜索节点值区间中，或等于某个带搜索节点，则可直接返回该节点为最近公共祖先

原因在于，若某个节点为公共祖先，那么较小的搜索值一定在这个节点为跟节点的左子树，较大的搜索值一定在这个节点为跟节点的右子树，

或者该节点为公共祖先（该节点值等于搜索值之一）

第一个出现在这个区间内的节点就为最近公共祖先，原因在于本题的二叉树是二叉搜索数，在往下遍历会出现两个搜索值都大于或小于子树根节点的情况，不再可能是公共祖先

前序遍历

基线条件：节点为空，返回空

否则，在每次递归内，若当前节点值在待搜索值区间内（大于最小值，小于最大值）或等于其中之一，则返回当前节点

    否则，若大于最大值，则递归调用函数，参数节点为左子节点，并返回调用结果

        否则，递归调用函数，参数节点为右子节点，并返回调用结果

## 71. #701 二叉搜索树中的插入操作
遍历二叉搜索数

递归函数：void traversal

基线条件：遇到当前节点的左子节点为空且目标值小于当前节点值，则声明并初始化一个值为目标值的节点并链接到当前节点的左子节点

遇到当前节点的右子节点为空且目标值大于当前节点值，则声明并初始化一个值为目标值的节点并链接到当前节点的右子节点

插入后可即可return掉，不再继续遍历

若不满足以上基线条件，就按照二叉搜索树的遍历方式遍历：当前值大于目标值，遍历左子树，否则，遍历右子树

主函数首先处理传入root为空的情况，否则调用traversal递归后返回root
## 72. #450 删除二叉搜索树中的节点

递归函数： TreeNode* traversal

基线条件：遇到空节点，return nullptr;

或者遇到节点的值等于key，分3种情况处理：

    1. 左右子节点皆为空，将当前节点赋为nullptr
    2. 左或右子节点一个为空一个非空，将非空的子节点赋给当前节点
    3. 左右子节点都非空，现将左子树链接到右子树的最左左叶子节点，再把用右子树的根节点替换掉当前节点

上述删除行为结束后，return当前节点

否则，在每次递归内，

若当前节点的值大于key，就递归搜索左子树，调用递归函数，参数为节点的左子节点，将返回值付给节点的左子节点

若当前节点的值小于key，就递归搜索右子树，调用递归函数，参数为节点的右子节点，将返回值付给节点的右子节点

不用void 递归函数的原因是：更改了子节点后，要建立或维护将新的子节点和原父节点的联系，

通过node->left = traversal(node->left)的方式做到

## 73. #669 修剪二叉搜索树

基线条件：遇到空节点，return nullptr;

否则若遇到超出范围的：

若节点值大于上限，且左节点为空，那么就return nullptr,若左节点非空，就调用递归函数处理左节点，并返回函数函数值

若节点值小于下限，且右节点为空，那么就return nullptr,若右节点非空，就调用递归函数处理右节点，并返回函数函数值

否则，依次对左右子节点调用递归函数，并将返回值赋给左右子节点，最后返回当前节点

## 74. #108 将有序数组转换为二叉搜索树

利用二叉搜索数中序遍历即为有序数组的特性

且转化为一个平衡二叉树，

可以将有序数组从中间切割，中间节点为根节点，截取左侧部分有序数组对应左子树，截取右侧有序数组对应右子树

基线条件为，截取出的数组的长度为零，返回nullptr

否则，将当前节点的值赋为中间值，然后调用递归函数，分别传入新截取的数组，返回值赋给左右节点（前序遍历）

返回当前节点

为了省掉不断声明截取数组占用的内存，传递数组索引值作为参数

## 75. #538 把二叉搜索树转换为累加树
以反中序（右中左）的方式遍历二叉搜索树即可

维护一个整数，用来记录上一次累加的结果（上一个节点值）

基线条件：空节点，返回空

每次递归内：先对右节点调用递归函数，

处理中节点：中节点的值等于其本身加上上一个节点的值，并更新上一个节点的值为当前中节点的值

再对左节点调用递归函数

最后return node;


# 七、 回溯

## 76. #77 组合
